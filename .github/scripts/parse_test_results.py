#!/usr/bin/env python3
"""
Parse CTest/GTest results and generate JSON summary.
Optimized for JUnit XML and robust log parsing.
"""
import os
import sys
import json
import re
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Dict, List, Optional

def parse_ctest_output(build_dir: str) -> Dict:
    """Parse CTest output from Testing directory (Fallback)."""
    results = {
        'total': 0, 'passed': 0, 'failed': 0, 'skipped': 0,
        'duration': 0.0, 'failed_tests': []
    }

    testing_dir = Path(build_dir) / 'Testing'

    # 1. Try Parsing standard Test.xml (Generated by -T Test)
    test_xml_files = sorted(list(testing_dir.glob('*/Test.xml')), reverse=True)
    if test_xml_files:
        try:
            tree = ET.parse(test_xml_files[0])
            for test in tree.findall('.//Test'):
                results['total'] += 1
                status = test.get('Status')
                name = test.findtext('.//Name', 'Unknown')

                # Get precise duration
                time_val = test.findtext('.//Results/NamedMeasurement[@name="Execution Time"]/Value')
                if time_val:
                    results['duration'] += float(time_val)

                if status == 'passed': results['passed'] += 1
                elif status == 'failed':
                    results['failed'] += 1
                    results['failed_tests'].append(name)
                else: results['skipped'] += 1
            print(f"‚úÖ Parsed CTest XML: {test_xml_files[0]}")
            return results
        except Exception:
            pass

    # 2. Fallback: Parse LastTest.log with improved Regex
    last_test_log = testing_dir / 'Temporary' / 'LastTest.log'
    if last_test_log.exists():
        print("üìã Parsing LastTest.log...")
        try:
            with open(last_test_log, 'r') as f:
                content = f.read()

                # Regex 1: Format verbose standard
                # Test #1: server_tests .....................   Passed    0.02 sec
                patterns = [
                    r'Test\s+#\d+:\s+(.+?)\s+\.+\s+(Passed|Failed)\s+([\d.]+)\s+sec',
                    r'"([^"]+)"\s+start\s+time:.*?Test\s+time\s+=\s+([\d.]+)\s+sec.*?Test\s+(Passed|Failed)'
                ]

                for pattern in patterns:
                    matches = re.finditer(pattern, content, re.MULTILINE)
                    found = False
                    for match in matches:
                        found = True
                        groups = match.groups()
                        # G√©rer l'ordre des groupes selon le pattern
                        if len(groups) == 3:
                            if pattern.startswith(r'Test'): # Pattern 1
                                name, status, duration = groups
                            else: # Pattern 2
                                name, duration, status = groups

                            results['total'] += 1
                            results['duration'] += float(duration)

                            if 'Passed' in status:
                                results['passed'] += 1
                            else:
                                results['failed'] += 1
                                results['failed_tests'].append(name)

                    if found: break # Stop if one pattern worked

        except Exception as e:
            print(f"‚ö†Ô∏è Error parsing log: {e}")

    return results

def parse_junit_xml(xml_path: str) -> Dict:
    """Parse JUnit XML output (High Precision)."""
    results = {
        'total': 0, 'passed': 0, 'failed': 0, 'skipped': 0,
        'duration': 0.0, 'failed_tests': []
    }
    try:
        tree = ET.parse(xml_path)
        root = tree.getroot()

        # Handle multiple testsuites or single testsuite
        suites = root.findall('.//testsuite') or [root] if root.tag == 'testsuite' else []

        for suite in suites:
            results['total'] += int(suite.get('tests', 0))
            results['failed'] += int(suite.get('failures', 0)) + int(suite.get('errors', 0))
            results['skipped'] += int(suite.get('skipped', 0))
            # JUnit duration is usually precise float
            results['duration'] += float(suite.get('time', 0))

            for case in suite.findall('testcase'):
                if case.find('failure') is not None or case.find('error') is not None:
                    results['failed_tests'].append(case.get('name', 'Unknown'))

        results['passed'] = results['total'] - results['failed'] - results['skipped']
        return results
    except Exception as e:
        print(f"‚ö†Ô∏è Error parsing JUnit: {e}")
        return results

def main():
    if len(sys.argv) < 2: return 1
    build_dir, output_file = sys.argv[1], sys.argv[2] if len(sys.argv) > 2 else 'test-results.json'

    # 1. Prioritize JUnit XML (Precision & Reliability)
    # Cherche test-results.xml (g√©n√©r√© par notre modif YAML) ou junit-results.xml
    junit_files = list(Path(build_dir).glob('**/*test-results.xml')) + \
                  list(Path('.').glob('**/*test-results.xml')) + \
                  list(Path(build_dir).glob('**/junit*.xml'))

    final_results = {'total': 0}

    if junit_files:
        print(f"üìÑ Found JUnit XML: {junit_files[0]}")
        final_results = parse_junit_xml(str(junit_files[0]))

    # 2. Fallback to CTest parsing if JUnit failed/empty
    if final_results['total'] == 0:
        print("‚ö†Ô∏è No JUnit data, falling back to CTest parsing")
        final_results = parse_ctest_output(build_dir)

    # Write output
    Path(output_file).parent.mkdir(parents=True, exist_ok=True)
    with open(output_file, 'w') as f: json.dump(final_results, f, indent=2)

    print(f"‚úÖ Results: {final_results['passed']}/{final_results['total']} passed in {final_results['duration']:.2f}s")
    return 0

if __name__ == '__main__': sys.exit(main())